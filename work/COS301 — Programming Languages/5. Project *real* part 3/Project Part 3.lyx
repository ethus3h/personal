#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extarticle
\begin_preamble
\usepackage{indentfirst}
\setmonofont[
  Contextuals={Alternate}
]{Fira Code}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman Wreathe
\font_sans Linux Biolinum O
\font_typewriter Fira Code
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf true
\font_sf_scale 70
\font_tt_scale 70
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize 17
\spacing other 1.5
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\texttt},columns=fullflexible,keepspaces=true,literate={-->}{\texttt{-->}}{1} {->}{\texttt{->}}{1} {==>}{\texttt{==>}}{1} {=>}{\texttt{=>}}{1}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Perl 6: Project: Part 3
\end_layout

\begin_layout Author
Elliot Chandler (Wallace)
\end_layout

\begin_layout Date
10 October 2017
\end_layout

\begin_layout Subsubsection*
Basic syntactic structure, including statement terminators or separators,
 block structure, syntactic peculiarities, etc.
\end_layout

\begin_layout Standard
Perl 6 has twenty-seven levels of precedence.
 All operators can be written as subroutines.
 
\begin_inset CommandInset citation
LatexCommand citep
key "Documentation"

\end_inset

 Custom operators are allowed.
 In Perl 6, blocks are typically denoted by braces (
\family typewriter
{
\family default
, 
\family typewriter
}
\family default
) and can be nested, and statements are delimited by semicolons (
\family typewriter
;
\family default
).
 The semicolons can be omitted in some circumstances, when then end of a
 statement is unambiguous.
 A block can be preceded by 
\family typewriter
-‌>
\family default
, with an interceding list of variables, called a 
\emph on
pointy block
\emph default
, which acts similarly to an anonymous function.
 Parentheses can be used to denote semantic divisions within a given block.
\end_layout

\begin_layout Subsubsection*
The units or levels of scope and the nature and type (runtime or compile-time)
 of name bindings within the different levels of scope.
\end_layout

\begin_layout Standard
By default, the scope of variables in Perl 6 is determined by the 
\emph on
declarator
\emph default
 with which the variable was declared (most commonly 
\family typewriter
my
\family default
).
 Perl 6 uses a variety of modifiers, called 
\emph on
twigils
\emph default
, to alter the default scoping.
 
\begin_inset CommandInset citation
LatexCommand citep
key "Documentation"

\end_inset

 There are seven declarators and two declarator-style prefixes, and there
 are nine twigils (not counting the absence of a twigil).
\end_layout

\begin_layout Subsubsection*
Primitive data types available, including range limitations or lack thereof.
\end_layout

\begin_layout Subsubsection*
Operators for primitive data types and their precedence and associativity.
\end_layout

\begin_layout Part*
Appendix: Program listing
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "numbers=left,basicstyle={\tiny\ttfamily},extendedchars=true"
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env perl6
\end_layout

\begin_layout Plain Layout
\noindent
\align left

\end_layout

\begin_layout Plain Layout

use v6.c;x
\end_layout

\begin_layout Plain Layout

use Test;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sub lex(Str $code --> List) {
\end_layout

\begin_layout Plain Layout

    my Pair @finishedTokens;
\end_layout

\begin_layout Plain Layout

    my Str $token;
\end_layout

\begin_layout Plain Layout

    my Str $prevChar = "None";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for $code.split("", :skip-empty) -> $char {
\end_layout

\begin_layout Plain Layout

        $_ := $char;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Subroutines for when something interesting is found
\end_layout

\begin_layout Plain Layout

        (
\end_layout

\begin_layout Plain Layout

            sub continue( --> Nil) {
\end_layout

\begin_layout Plain Layout

                # Accepted an identifier-part
\end_layout

\begin_layout Plain Layout

                $token ~= $char;
\end_layout

\begin_layout Plain Layout

                $prevChar = $char;
\end_layout

\begin_layout Plain Layout

                next
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            sub push(Str $type --> Nil) {
\end_layout

\begin_layout Plain Layout

                $_ := $type;
\end_layout

\begin_layout Plain Layout

                if $prevChar ~~ /<:L + :N>/ {
\end_layout

\begin_layout Plain Layout

                    # Found something non-identifier after an identifier,
\end_layout

\begin_layout Plain Layout

                    #   so push the identifier
\end_layout

\begin_layout Plain Layout

                    @finishedTokens.push("identifier" => "$token");
\end_layout

\begin_layout Plain Layout

                    $token = ""
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                # Found a token
\end_layout

\begin_layout Plain Layout

                $token ~= $char;
\end_layout

\begin_layout Plain Layout

                @finishedTokens.push($type => "$token");
\end_layout

\begin_layout Plain Layout

                $prevChar = $char;
\end_layout

\begin_layout Plain Layout

                $token = "";
\end_layout

\begin_layout Plain Layout

                next
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Rules for figuring out what the lexer is looking at
\end_layout

\begin_layout Plain Layout

        (
\end_layout

\begin_layout Plain Layout

            if $token ∈ <tru fals> {
\end_layout

\begin_layout Plain Layout

                when "e" {
\end_layout

\begin_layout Plain Layout

                    push 'bool_literal'
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            when /<:L + :N>/ {
\end_layout

\begin_layout Plain Layout

                when /<:N>/ && $prevChar !~~ /<:L>/ {
\end_layout

\begin_layout Plain Layout

                    fail "Expected an identifier or an operator."
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    continue
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            if $_ ∈ < ( ) > {
\end_layout

\begin_layout Plain Layout

                push 'parenthesis'
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            when '!' {
\end_layout

\begin_layout Plain Layout

                push 'unary_oper'
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            when $_ ∈ < & | 
\backslash
< 
\backslash
> > {
\end_layout

\begin_layout Plain Layout

                push 'binary_oper'
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            when /
\backslash
s/ {
\end_layout

\begin_layout Plain Layout

                # Skip this space
\end_layout

\begin_layout Plain Layout

                next
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            default {
\end_layout

\begin_layout Plain Layout

                fail 'Input character is not in the language: "' ~ $char
 ~ '"'
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        );
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # If there aren't any more characters to consume
\end_layout

\begin_layout Plain Layout

    # but there is still a token, it's an identifier
\end_layout

\begin_layout Plain Layout

    if $token ne '' {
\end_layout

\begin_layout Plain Layout

        @finishedTokens.push('identifier' => $token)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return @finishedTokens
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sub parse(List $tokens --> Nil) {
\end_layout

\begin_layout Plain Layout

    my Pair @state;
\end_layout

\begin_layout Plain Layout

    my Pair @consumed;
\end_layout

\begin_layout Plain Layout

    my Pair @input = $tokens.clone;
\end_layout

\begin_layout Plain Layout

    my Pair $token = "" => "";
\end_layout

\begin_layout Plain Layout

    my Str $lexeme = "";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Support subroutines for the parser
\end_layout

\begin_layout Plain Layout

    (
\end_layout

\begin_layout Plain Layout

        sub lexeme( --> Pair) {
\end_layout

\begin_layout Plain Layout

            $_ = shift(@input);
\end_layout

\begin_layout Plain Layout

            say $_;
\end_layout

\begin_layout Plain Layout

            $lexeme = ~ $_;
\end_layout

\begin_layout Plain Layout

            unshift(@consumed, $_);
\end_layout

\begin_layout Plain Layout

            when "" => "" {
\end_layout

\begin_layout Plain Layout

                # do nothing, we don't have any token yet
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            default {
\end_layout

\begin_layout Plain Layout

                say "Next token is the " ~ .key ~ " " ~ .value;
\end_layout

\begin_layout Plain Layout

                #say "    State: 
\backslash
n" ~ @state;
\end_layout

\begin_layout Plain Layout

                #say "    Consumed: 
\backslash
n" ~ @consumed;
\end_layout

\begin_layout Plain Layout

                return $_
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub enter(Str $rule --> Nil) {
\end_layout

\begin_layout Plain Layout

            say "Enter <$rule>";
\end_layout

\begin_layout Plain Layout

            @state.push("    " x @consumed.elems ~ "<$rule>: " => "Lexeme:
 
\backslash
{ $lexeme 
\backslash
}
\backslash
n");
\end_layout

\begin_layout Plain Layout

            #say "    State: 
\backslash
n" ~ @state;
\end_layout

\begin_layout Plain Layout

            #say "    Consumed: 
\backslash
n" ~ @consumed;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub give_back( --> Nil) {
\end_layout

\begin_layout Plain Layout

            @state.pop();
\end_layout

\begin_layout Plain Layout

            say "Releasing tokens ";
\end_layout

\begin_layout Plain Layout

            for @consumed {
\end_layout

\begin_layout Plain Layout

                unshift(@input, (shift(@consumed)))
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            @consumed = < >;
\end_layout

\begin_layout Plain Layout

            #say "    State: 
\backslash
n" ~ @state;
\end_layout

\begin_layout Plain Layout

            #say "    Consumed: 
\backslash
n" ~ @consumed;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Rules for the parser
\end_layout

\begin_layout Plain Layout

    (
\end_layout

\begin_layout Plain Layout

        sub bool_literal( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "bool_literal";
\end_layout

\begin_layout Plain Layout

            my Str $test where * eq "bool_literal";
\end_layout

\begin_layout Plain Layout

            $test = lexeme().key;
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub relop( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "relop";
\end_layout

\begin_layout Plain Layout

            my Str $test where * ∈ < 
\backslash
< 
\backslash
> >;
\end_layout

\begin_layout Plain Layout

            $test = lexeme().value;
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub id( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "id";
\end_layout

\begin_layout Plain Layout

            lexeme().key eq "identifier";
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub relation_expr( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "relation_expr";
\end_layout

\begin_layout Plain Layout

            id;
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                while relop() {
\end_layout

\begin_layout Plain Layout

                    id
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                CATCH {
\end_layout

\begin_layout Plain Layout

                    default {
\end_layout

\begin_layout Plain Layout

                        say "(Matched short relop)"
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub bool_factor( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "bool_factor";
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                bool_literal();
\end_layout

\begin_layout Plain Layout

                CATCH {
\end_layout

\begin_layout Plain Layout

                    default {
\end_layout

\begin_layout Plain Layout

                        my Str $lexeme = lexeme().value;
\end_layout

\begin_layout Plain Layout

                        my $extest where * eq '!';
\end_layout

\begin_layout Plain Layout

                        $extest = $lexeme;
\end_layout

\begin_layout Plain Layout

                        bool_factor;
\end_layout

\begin_layout Plain Layout

                        CATCH {
\end_layout

\begin_layout Plain Layout

                            default {
\end_layout

\begin_layout Plain Layout

                                my $lptest where * eq '(';
\end_layout

\begin_layout Plain Layout

                                $lptest = $lexeme;
\end_layout

\begin_layout Plain Layout

                                $lexeme eq "(";
\end_layout

\begin_layout Plain Layout

                                bool_expr;
\end_layout

\begin_layout Plain Layout

                                my $rptest where * eq ')';
\end_layout

\begin_layout Plain Layout

                                $rptest = lexeme;
\end_layout

\begin_layout Plain Layout

                                CATCH {
\end_layout

\begin_layout Plain Layout

                                    default {
\end_layout

\begin_layout Plain Layout

                                        relation_expr
\end_layout

\begin_layout Plain Layout

                                    }
\end_layout

\begin_layout Plain Layout

                                }
\end_layout

\begin_layout Plain Layout

                            }
\end_layout

\begin_layout Plain Layout

                        }
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub and_term( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "and_term";
\end_layout

\begin_layout Plain Layout

            bool_factor;
\end_layout

\begin_layout Plain Layout

            while lexeme().value eq "&" {
\end_layout

\begin_layout Plain Layout

                bool_factor
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        sub bool_expr( --> Nil) {
\end_layout

\begin_layout Plain Layout

            enter "bool_expr";
\end_layout

\begin_layout Plain Layout

            and_term;
\end_layout

\begin_layout Plain Layout

            while lexeme().value eq "|" {
\end_layout

\begin_layout Plain Layout

                and_term
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            CATCH {
\end_layout

\begin_layout Plain Layout

                default {
\end_layout

\begin_layout Plain Layout

                    give_back;
\end_layout

\begin_layout Plain Layout

                    X::AdHoc.new(:payload<Did not match>).throw
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Enter the parser from the top of the tree
\end_layout

\begin_layout Plain Layout

    bool_expr;
\end_layout

\begin_layout Plain Layout

    if @input.elems > 0 {
\end_layout

\begin_layout Plain Layout

        fail "The input string does not match the grammar.
 Unused input: " ~ @input
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    say @state;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Test suite
\end_layout

\begin_layout Plain Layout

(
\end_layout

\begin_layout Plain Layout

    # Test lexer
\end_layout

\begin_layout Plain Layout

    nok lex('String qux?');
\end_layout

\begin_layout Plain Layout

    isa-ok lex('Stringqux'), List;
\end_layout

\begin_layout Plain Layout

    isa-ok lex('foo & !( a2 > bar & w < foo | x < y)'), List;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Test parser
\end_layout

\begin_layout Plain Layout

    #lex('foo & !( a2 > bar & w < foo | x < y)')
\end_layout

\begin_layout Plain Layout

    #    ==> parse;
\end_layout

\begin_layout Plain Layout

    say parse(lex('foo & !( a2 > bar & w < foo | x < y('));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    say "Done running tests.
 Report:";
\end_layout

\begin_layout Plain Layout

    done-testing;
\end_layout

\begin_layout Plain Layout

);
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "2017sept20-p6bib"
options "apa"

\end_inset


\end_layout

\end_body
\end_document
