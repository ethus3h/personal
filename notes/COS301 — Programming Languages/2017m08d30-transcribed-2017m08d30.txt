COS301  30 Aug. 2017<ambig>.,[nothing]</ambig>  p.1

_Web_                               Client-[illeg.]-\-side — JS — knows DOM
                                    Server-side — PHP, etc. — DB
                                      access, maybe DOM understanding

_Embedded_                          Similarities w/ systems programming

                                    C, etc.  Somewhat, Java.

_Consumer_
    _apps_                          Desktop, laptop, mobile
                                    C, C-⿻⿰||—-++, C#, Swift, Objective C

_Military applications_
                                    Wide range of applications
                                    Virtually<caret-insertion pos="above"> all</caret-insertion> of the preceding
                                    Languages: C, Ada, C++, …

_Language_
  _Evaluation_                      How to see if a language is
                                    something we want to use?
                                    Axes:   Readability,
                                            reliability, writability,
                                            cost

_Readability_                       More important for machine to "read"
                                                                   code
                                    than to be efficient to write.<note>This was referring to the state in the 1970s.</note>
                                    After,<caret-insertion pos="below"> realized</caret-insertion> sw maintenance cost ≫ dev.
                                                                                                                           cost
                                    Memory — compilers/interpreters
                                               for more readable langs
                                                  can be large
                                    Aspects — Simplicity,  Orthagonality,
                                          Syntax
                                                                        →cont'd.

==

←cont'd.  COS301  30 Aug. 2017  p.2

Documentation, and also making the
  code itself readable.

_Syntax_                            ↑Size of language feature set ⇒ ↓
                                                                    readability
                                    Subsets<caret-insertion pos="above"> (e.g. -optional sub- for different -pur[?]- purposes)</caret-insertion> -can de- <[?]><italic></[?]>_can_<[?]></italic></[?]> decrease
                                                                   readability.
                                Canonical features vs feature multiplicity:
                                    i = i+1; i++; ++i; i+=1; i=+1;
                                Operator overloading decreases -readability-
                                  readability. E.g. + for floating point,
                                    int, string concat.
                                Especially confusing: user-defined overloading

_Orthogonality_                     — large feature set, or small
                                    primitive constructs to combine?
                                  Canonical: one and only one way to
                                    express something:
                                        ⛤ Primitive constructs all
                                          -treated- treated alike
                                        ⛤ all combinations legal w/ all
                                          constructs
                                        ⛤ all combinations -re- behave
                                                             ↑  same way
  (crossed<caret-insertion pos="below">out</caret-insertion> re)
Identifiers (length, characters allowed) affect
                                        readability
Compound statement syntax — deeply nested
                               code
                                                            →cont'd.

==

← cont'd.  COS301
               30 Aug. 2017  p. -2- 3
    Space indentation, such as in Python,
         is good in an IDE but
           hard  to read on paper.
    Different meanings of<caret-insertion pos="above"> the same</caret-insertion> keyword

_Writability_                   How easy is it for a programmer to
                                  write a program?

                                Can depend on purpose (e.g.
                                  Python vs. C for an OS)
-Sy- Simplicity / orthogonality generally
                  increases writeability
         but can result in inappropriate use of unfamiliar
                                                      features
         e.g. C++
                cout « (1 «2); -pr[?]- prints 4
                vs. cout « 1<ambig> ,[nothing]</ambig>«<ambig> ,[nothing]</ambig>2; prints 12
            -but-
Abstraction — allows treating complex structures
             / operations as black boxes.
             Support for abstraction increases
                   -reada<[?]>b</[?]>- writeability.
    Application-specific data -types- types
Can languages express what is needed for problem?
Number, power of operators increases expressivity
Number of predefined fns increases        〃
COBOL — many operations for file types
   APL — many operations for math
                                    →cont'd.

==

←cont'd.  COS301  30 Aug. 2017  p.4

_Reliability_                 — Is the program produced by the
                                language reliable?
                                -R- Safety & correctness
                                    checks
                            Type checking, exc. handling
                             — can be compile time or run<ambig> ,[nothing]</ambig>time
                            Runtime checking: expensive
                            Compile time checking: decreases
                                                     writeability[sic]
                            Runtime type checking helps
                            writeability & decreases
                               reliability.

-Excc- _Exception handling_     Ways to handle
                                runtime errors. Security &
                                correctness impacted by lack of
                                exception handling.

_Aliasing_                      decreases -ri- reliability.
                                Multiple names for one thing.
                                Problem: Multiple accesses to
                                same location / object w/o
                                  realizing it
Lack of expressiveness ⇒ unnatural-/-convoluted
                                algorithms & programming
                                decreases reliability & -readabi-
                                readability.
                                                    →cont'd.

==

←cont'd.  COS301  30 Aug. 2017  p. 5

Poor readability decreases reliability
                            e.g. APL, Perl — -"write[illeg.]- "write-only"
                                                   languages
Cost (not cost of compilers — -we- use
                                GNU)
                            — ⛤ time costs — training, compilation speed, execution efficiency, reliability
                            — ⛤ direct monetary costs — e.g. delay selling product
                            — ⛤ other — privacy breaches, data loss, etc.

Other 
